# url
## https://www.bilibili.com/video/BV1ZW411N7jq?p=67
# javascript基础-语法
## javascript ==》 js
### 三部分组成
    .ECMAScript  ==> js基础语法
    .DOM         ==> 文档对象模型 document object modal
    .BOM         ==> 浏览器对象模型 broswer object modal
## javascript语言特点
    是一门动态性 解释性 基于面向对象的脚本语言 
    .借鉴了C语的基本语言
    .借鉴了java的数据类型和内存管理
    .借鉴了scheme语言的，将函数提升到第一等公民
    .借鉴seif语言，使用基于原型到prototype的继承机制
## javascript原始数据类型
    .number
    .string
    .boolean
    .null
    .undefined： 声明变量了但是没有赋值，结果是undefined或者是
    函数没有明确返回值，如果接受了，结果也是undefined
    .object
    获取原始数据的数据类型： typeof 
## 进制
    .二进制： 2进一     0000 0100  ==》 4
    .十进制： 10进一    0000
    .八进制： 8进一     0000 0011  ==》 9
    .十六进制：f进一    0000 000f  ==> 15
## 0.1 + 0.2 = 0.3? why?
    原因在于在js中采用的IEEE 754的双精度标准，计算机内部存储数据的编码的时候，0.1在
    计算机内部根本就不是精确的0.1，而是一个有舍入误差的0.1，当代码被编译或解释后，
    0.1已经被四舍五入成一个与之很接近的计算机内部数字，以至于计算还没有开始，一个很小的
    舍入错误就已经产生了。这也就是0.1 + 0.2 ！= 0.3的原因
    注意： 不是所有的浮点型都有舍入的误差。二进制能精确地表示位数有限且分母是2的倍数的小数
    比如0.5 0.5在计算机内就没有舍入的误差，
    有时候两个近似值进行计算的时候，得到的值是在js的近似值范围内的，于是就能得到正确的答案
    解决的最好的方法就是想办法避免掉这类小数计算时的精度问题就好了，最常用的方法，就是将浮点数
    转成整数计算。因为证书都是可以精确表示的。
## 类型转换
    .parseInt() 转整数
    .parseFloat() 转小数
    .Number() 转数字
    ---
    .toString() 转字符串类型 如果变量有意义调此方法
    .String() 转字符串 如果变量没有意思调此方法
    .Boolean()
## arguments

## 作用域
    . 